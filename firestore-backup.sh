#!/bin/bash

# Created by argbash-init v2.9.0
# ARG_OPTIONAL_SINGLE([credentials],[],[Auth credentials file absolute path and name, defaults to \$(pwd)/credentials.json])
# ARG_OPTIONAL_SINGLE([collections],[],[Collections to be exported, can be blank])
# ARG_OPTIONAL_SINGLE([rotation-days],[],[Rotation days, e.g. 30 indicates that when doing a new backup, those older than 30 days will be deleted. If no flag then deletion is disabled])
# ARG_OPTIONAL_BOOLEAN([quiet])
# ARG_OPTIONAL_BOOLEAN([dry-run])
# ARG_POSITIONAL_SINGLE([project],[Poject name])
# ARG_POSITIONAL_SINGLE([region],[Region])
# ARG_POSITIONAL_SINGLE([bucket-address],[Bucket address, e.g. gs://project-backup-bucket/])
# ARG_POSITIONAL_SINGLE([service-account],[Service account to use, must have export access on firestore and write access on bucket])
# ARG_DEFAULTS_POS()
# ARG_HELP([Firebase backup helper])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='h'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_project=
_arg_region=
_arg_bucket_address=
_arg_service_account=
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_credentials=
_arg_collections=
_arg_rotation_days=
_arg_quiet="off"
_arg_dry_run="off"


print_help()
{
	printf '%s\n' "Firebase backup helper"
	printf 'Usage: %s [--credentials <arg>] [--collections <arg>] [--rotation-days <arg>] [--(no-)quiet] [--(no-)dry-run] [-h|--help] <project> <region> <bucket-address> <service-account>\n' "$0"
	printf '\t%s\n' "<project>: Poject name"
	printf '\t%s\n' "<region>: Region"
	printf '\t%s\n' "<bucket-address>: Bucket address, e.g. gs://project-backup-bucket/"
	printf '\t%s\n' "<service-account>: Service account to use, must have export access on firestore and write access on bucket"
	printf '\t%s\n' "--credentials: Auth credentials file absolute path and name, defaults to \$(pwd)/credentials.json (no default)"
	printf '\t%s\n' "--collections: Collections to be exported, can be blank (no default)"
	printf '\t%s\n' "--rotation-days: Rotation days, e.g. 30 indicates that when doing a new backup, those older than 30 days will be deleted. If no flag then deletion is disabled (no default)"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			--credentials)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_credentials="$2"
				shift
				;;
			--credentials=*)
				_arg_credentials="${_key##--credentials=}"
				;;
			--collections)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_collections="$2"
				shift
				;;
			--collections=*)
				_arg_collections="${_key##--collections=}"
				;;
			--rotation-days)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_rotation_days="$2"
				shift
				;;
			--rotation-days=*)
				_arg_rotation_days="${_key##--rotation-days=}"
				;;
			--no-quiet|--quiet)
				_arg_quiet="on"
				test "${1:0:5}" = "--no-" && _arg_quiet="off"
				;;
			--no-dry-run|--dry-run)
				_arg_dry_run="on"
				test "${1:0:5}" = "--no-" && _arg_dry_run="off"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'project', 'region', 'bucket-address' and 'service-account'"
	test "${_positionals_count}" -ge 4 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 4 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 4 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 4 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_project _arg_region _arg_bucket_address _arg_service_account "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


say () {
	if [ "$_arg_quiet" = "off" ];
	then
		printf "%s\\n" "$1"
	fi
}

run () {
	if [ "$_arg_dry_run" = "off" ];
	then
		eval "$1"
    else
        say "Dry-run enabled [CMD]: $1"
	fi
}

REGEX_BUCKET_NAME="^gs://[a-zA-Z0-9\-]*/[_\:0-9A-Z\-]*/$"
REGEX_OBJECT_DATE="^gs://[a-zA-Z0-9\-]*/([0-9\-]*)T[_\:0-9]*/$"
[ -z $_arg_credentials ] && _arg_credentials=$(pwd)"/credentials.json"


gcloud_auth () {
    CMD="gcloud auth activate-service-account $_arg_service_account --key-file=$_arg_credentials"
    run "$CMD"
    if [ $? -ne 0 ];
    then
        die "Can't log into gcloud"
    fi
}

export () {
    local collections=""
    if [ ! -z $_arg_collections ];
    then
        collections="--collection-ids="$_arg_collections
    fi
    CMD="gcloud firestore export $_arg_bucket_address --project $_arg_project $collections"
    run "$CMD"
    if [ $? -ne 0 ];
    then
        die "Can't export"
    fi

}

get_objects () {
    CMD="gsutil ls $_arg_bucket_address"
    run "$CMD"
}

evaluate_object_2b_deleted () {
    if [[ "$1" =~ $REGEX_BUCKET_NAME ]];
    then
        DATE=$(echo $1 | sed -E 's|'$REGEX_OBJECT_DATE'|\1|')
        if [ "$DATE" = "$1" ];
        then
            die "Can't extract date"
        fi
        DIFF=$(( ($(date +"%s") - $(date -d $DATE +"%s") )/(60*60*24) ))
        if [ $DIFF -gt $_arg_rotation_days ];
        then
            echo $DIFF
        else
            echo 0
        fi
    else
        die "Name $1 does not match $REGEX_BUCKET_NAME"
    fi
}

delete () {
    say "deleting $1..."
    say "gsutil rm -r $1"
}

say "Login..."
gcloud_auth

say "Exporting..."
export

if [ ! -z $_arg_rotation_days ];
then
    say "doing"
    O=$(get_objects)
	if [ "$_arg_dry_run" = "off" ];
    then
        for o in $O;
        do
            if [ $(evaluate_object_2b_deleted $o) -ne 0 ];
            then
                delete $o
            else
                say "$o won't be deleted"
            fi
        done
    fi
fi

# ] <-- needed because of Argbash
